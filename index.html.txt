Of course. I have analyzed the provided code and implemented several improvements to fix logical issues, enhance performance, and improve the user experience.

Here are the key changes I've made:

1.  **Corrected Trading Logic:** The bet amount is now deducted from your balance at the precise moment the trading round begins, not when you confirm the bet. This is a more accurate and fair simulation.
2.  **Added Trade Cancellation:** You can now cancel a placed bet at any time during the "waiting" period before the trade becomes active.
3.  **Improved Performance:** I've removed a redundant rendering timer (`livePriceTick`) and integrated its function into the main animation loop (`render`), which reduces unnecessary processing and makes the price updates smoother.
4.  **Enhanced UI Feedback:** The "Buy" and "Sell" buttons now provide clearer feedback. They are replaced by a "Cancel" button when a trade is pending, and they have helpful tooltips when disabled during an active trade.
5.  **Code Refactoring:** The JavaScript code has been reorganized for better readability and maintainability.

Here is the complete, revised code. You can replace the entire original file with this new version.

```html
<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="UTF-8" />
<title>Crypto Trade Pro - N√¢ng C·∫•p To√†n Di·ªán</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
<style>
/* --- CSS Variables cho c·∫£ 2 theme --- */
:root {
    --bg:#0a0e16; --panel:#121826; --text:#e0e0e0; --muted:#888;
    --grid:#2a3040; --green:#26a69a; --red:#ef5350; --blue: #2962ff; --yellow: #ffa000;
    --modal-input-bg: #0a0e16;
}
body.light-theme {
    --bg:#f0f2f5; --panel:#ffffff; --text:#1c1e21; --muted:#65676b;
    --grid:#e0e2e7; --green:#00a442; --red:#fa383e; --blue: #1877f2; --yellow: #f5a623;
    --modal-input-bg: #f0f2f5;
}
html { font-size: 16px; }
body { margin:0; background:var(--bg); color:var(--text); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; font-size: 14px; user-select: none; transition: background 0.3s, color 0.3s; }
.top-bar { position:fixed; top:0; left:0; width:100%; display:flex; justify-content:space-between; padding:8px; background:var(--panel); border-bottom:1px solid var(--grid); z-index:10; box-sizing: border-box; transition: background 0.3s, border-bottom 0.3s;}
.top-bar button, .top-bar select { background:#2a3040; color:var(--text); border:1px solid #555; padding:6px 12px; border-radius:6px; cursor:pointer; font-size:14px; transition: background .2s; }
.top-bar button:hover, .top-bar select:hover { background:#3c445c; }
.top-bar-group { display:flex; gap:8px; align-items: center; }
header { text-align:center; padding-top:60px; }
h2 { margin:10px 0 6px; font-weight:700; }
.wallet-row { margin:0 auto 10px; display:flex; gap:10px; justify-content:center; flex-wrap:wrap; }
.pill { background:#2a3040; border:1px solid #555; border-radius:999px; padding:6px 14px; font-size:14px; transition: background 0.3s, border-color 0.3s;}
#balance-pill { transition: all 0.2s ease-out; }
.flash-green { transform: scale(1.1); background-color: var(--green) !important; color: white !important; border-color: var(--green) !important; }
.flash-red { transform: scale(1.1); background-color: var(--red) !important; color: white !important; border-color: var(--red) !important; }
.chart-wrap { max-width:1200px; margin:10px auto 0; padding:0 10px; position:relative; }
canvas { background:var(--panel); width:100%; height:auto; border-radius:8px; display:block; cursor:crosshair; transition: background 0.3s;}
.axis-label { position:absolute; right:16px; transform:translateY(-50%); background:rgba(10, 14, 22, 0.7); padding:2px 6px; border-radius:4px; font-size:12px; color:#ccc; pointer-events: none; }
.live-price-label { position:absolute; right:16px; padding: 4px 8px; border-radius: 4px; font-size: 12px; font-weight: bold; pointer-events: none; transition: top 0.1s linear; color: #fff; }
.panel { background: var(--panel); max-width:1200px; margin:10px auto 0; padding:15px; border-radius:8px; box-sizing: border-box; transition: background 0.3s;}
.panel-row { display: flex; justify-content: space-around; align-items: center; text-align: center; flex-wrap: wrap; gap: 15px; }
.panel-buttons button { width: 45%; max-width: 150px; padding: 14px 20px; border:none; border-radius:6px; cursor:pointer; font-size:18px; font-weight:bold; transition: opacity .2s, background-color .2s; }
.panel-buttons button.btn-cancel-trade { background: var(--yellow); color: #000; width: 90%; max-width: 310px;}
.panel-buttons button:disabled { opacity: 0.5; cursor: not-allowed; }
.btn-buy { background:var(--green); color:#fff; } .btn-sell{ background:var(--red); color:#fff; }
.timer { font-size:24px; font-weight:bold; color:var(--yellow); min-height:30px; }
.dt { color:var(--muted); font-size:12px; margin-top:4px; }
#profitMsg { position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); font-size:48px; font-weight:800; pointer-events:none; opacity:0; text-shadow: 0 0 15px rgba(0,0,0,0.7); z-index: 999; }
@keyframes floatUp { 0% { transform:translate(-50%,-50%); opacity:1; } 100% { transform:translate(-50%,-150%); opacity:0; } }
#profitMsg.animate { animation: floatUp 1.8s ease-out forwards; }
#history { max-width:1200px; margin:15px auto 20px; padding:0 10px; }
.history-header { display: flex; justify-content: space-between; align-items: center; border-bottom:1px solid var(--grid); padding-bottom: 8px; }
#history .box { padding-top:12px; }
#history ul { list-style:none; padding:0; margin:8px 0 0; font-size:14px; max-height: 200px; overflow-y: auto;}
#history li { display:flex; justify-content: space-between; padding:8px 4px; border-bottom:1px dashed var(--grid); flex-wrap: wrap; gap: 5px; }
.history-col { flex-basis: 25%; text-align: left; min-width: 120px; }
.history-col.right { text-align: right; }
.green{ color:var(--green); } .red{ color:var(--red); }
#clearHistoryBtn { background: none; border: 1px solid var(--muted); color: var(--muted); padding: 4px 8px; border-radius: 4px; cursor: pointer; transition: all .2s; }
#clearHistoryBtn:hover { border-color: var(--red); color: var(--red); }
.modal-backdrop { position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:100; display:none; justify-content:center; align-items:center; }
.modal-content { background:var(--panel); padding:20px; border-radius:8px; width: 90%; max-width: 340px; border:1px solid var(--grid); text-align:center; transition: background 0.3s;}
.modal-content h3 { margin-top:0; }
.modal-content input, .modal-content select { width:100%; padding:10px; margin:10px 0; border-radius:4px; border:1px solid var(--grid); background:var(--modal-input-bg); color:var(--text); font-size:16px; box-sizing: border-box; transition: background 0.3s, color 0.3s;}
.modal-content .modal-buttons { display:flex; gap:10px; justify-content:flex-end; margin-top:20px; }
.modal-content button { padding:8px 16px; border-radius:4px; border:none; cursor:pointer; }
.bet-info { font-size: 13px; text-align: left; margin-top: 15px; padding-top: 10px; border-top: 1px solid var(--grid); }
.settings-row { display: flex; justify-content: space-between; align-items: center; margin: 10px 0;}
.btn-confirm { background:var(--blue); color:#fff; }
.btn-cancel { background:#444; color:#fff; }
.modal-backdrop.active { display:flex; }
/* N√¢ng c·∫•p CSS */
#rsi-chart-wrap { max-width:1200px; margin:0px auto; padding:0 10px; position:relative; }
#rsi-chart { background: var(--panel); border-radius: 8px; border: 1px solid var(--grid); margin-top: 10px; }
.rsi-label { position: absolute; right: 16px; font-size: 12px; color: #fff; padding: 2px 6px; border-radius: 4px; z-index: 5; }
.rsi-label.overbought { background: var(--red); }
.rsi-label.oversold { background: var(--green); }
.rsi-label.neutral { background: #333; }
#pl-line { position: absolute; top: 0; left: 0; width: 100%; height: 2px; background: transparent; border-top: 2px dashed; }
#pl-label { position: absolute; font-size: 12px; font-weight: bold; padding: 2px 6px; border-radius: 4px; transform: translateX(-50%); pointer-events: none; }
#countdown-bar {
    max-width: 1200px; margin: 10px auto 0; height: 8px; background-color: var(--green);
    border-radius: 4px; transform-origin: left; animation-timing-function: linear;
}
@keyframes countdown { from { width: 100%; background-color: var(--green); } to { width: 0%; background-color: var(--red); } }
#waiting-bar {
    max-width: 1200px; margin: 10px auto 0; height: 8px; background-color: var(--yellow);
    border-radius: 4px; transform-origin: left; animation-timing-function: linear;
}
@keyframes waiting { from { width: 100%; background-color: var(--yellow); } to { width: 0%; background-color: var(--yellow); } }
</style>
</head>
<body>
<div class="top-bar">
    <div class="top-bar-group">
        <button id="themeToggleBtn">üåô</button>
        <select id="coinSelector" onchange="switchCoin(this.value)">
            <option value="bitcoin">BTC/USDT</option>
            <option value="ethereum">ETH/USDT</option>
            <option value="solana">SOL/USDT</option>
        </select>
        <button onclick="showModal('settingsModal')">‚öôÔ∏è C√†i ƒë·∫∑t</button>
    </div>
    <div class="top-bar-group">
        <button onclick="showModal('depositModal')">üí∞ N·∫°p</button>
        <button onclick="showModal('withdrawModal')">üí∏ R√∫t</button>
    </div>
</div>
<header><h2><span id="pairTitle">Trade BTC/USDT</span> (Gi√° Th·ª±c)</h2><div class="wallet-row"><span class="pill" id="balance-pill">S·ªë d∆∞: <b id="balance">1000.00</b> USDT</span><span class="pill">Tr·∫£ th∆∞·ªüng: <b id="payoutRateDisplay">85</b>%</span></div></header>
<div class="chart-wrap"><canvas id="chart"></canvas><div id="axisMax" class="axis-label"></div><div id="axisMid" class="axis-label" style="top:50%;"></div><div id="axisMin" class="axis-label"></div><div id="livePriceLine" style="position:absolute; width:100%; height:1px; border-top: 1px dashed #ffa000; pointer-events:none; transition: top 0.1s linear;"></div><div id="livePriceLabel" class="live-price-label"></div><div id="pl-line" style="display: none;"></div><div id="pl-label" style="display: none;"></div></div>
<div id="rsi-chart-wrap"><canvas id="rsi-chart" width="960" height="120"></canvas><span class="rsi-label overbought" style="top: 25%;">70</span><span class="rsi-label neutral" style="top: 50%;">50</span><span class="rsi-label oversold" style="top: 75%;">30</span></div>
<div id="waiting-bar" style="display: none;"></div>
<div id="countdown-bar" style="display: none;"></div>
<div class="panel"><div class="panel-row"><div class="current-price"><div id="priceLabel">Gi√° BTC (CoinGecko)</div><div id="price" style="font-size: 20px; font-weight: bold; margin-top: 5px;">ƒêang t·∫£i...</div></div><div class="timer-section"><div>Th·ªùi gian c√≤n l·∫°i</div><div class="timer" id="timer">--:--</div><div class="dt"><span id="date"></span> | <span id="time"></span></div></div><div class="panel-buttons" id="panelButtons"><button class="btn-buy" id="btnBuy" onclick="showModal('betModal', 'buy')">MUA</button><button class="btn-sell" id="btnSell" onclick="showModal('betModal', 'sell')">B√ÅN</button></div></div></div>
<div id="profitMsg"></div>
<section id="history"><div class="box"><div class="history-header"><b>L·ªãch s·ª≠ giao d·ªãch</b><button id="clearHistoryBtn" onclick="clearHistory()">üóëÔ∏è X√≥a L·ªãch S·ª≠</button></div><ul id="historyList"></ul></div></section>
<div id="betModal" class="modal-backdrop"><div class="modal-content"><h3 id="betModalTitle">ƒê·∫∑t L·ªánh</h3><input type="number" id="betAmountInput" placeholder="VD: 10" value="10"><div class="bet-info"><div>L·ª£i nhu·∫≠n n·∫øu th·∫Øng: <span class="green" id="potentialProfit">0.00 USDT</span></div><div>R·ªßi ro n·∫øu thua: <span class="red" id="potentialLoss">0.00 USDT</span></div></div><div class="modal-buttons"><button class="btn-cancel" onclick="hideModal('betModal')">H·ªßy</button><button class="btn-confirm" id="confirmBetBtn">X√°c nh·∫≠n</button></div></div></div>
<div id="depositModal" class="modal-backdrop"><div class="modal-content"><h3>N·∫°p USDT</h3><input type="number" id="depositAmountInput" placeholder="Nh·∫≠p s·ªë ti·ªÅn" value="100"><div class="modal-buttons"><button class="btn-cancel" onclick="hideModal('depositModal')">H·ªßy</button><button class="btn-confirm" onclick="deposit()">X√°c nh·∫≠n</button></div></div></div>
<div id="withdrawModal" class="modal-backdrop"><div class="modal-content"><h3>R√∫t USDT</h3><input type="number" id="withdrawAmountInput" placeholder="Nh·∫≠p s·ªë ti·ªÅn" value="100"><div class="modal-buttons"><button class="btn-cancel" onclick="hideModal('withdrawModal')">H·ªßy</button><button class="btn-confirm" onclick="withdraw()">X√°c nh·∫≠n</button></div></div></div>
<div id="settingsModal" class="modal-backdrop"><div class="modal-content"><h3>C√†i ƒë·∫∑t</h3><div class="settings-row"><label for="payoutRateInput">T·ª∑ l·ªá tr·∫£ th∆∞·ªüng (%):</label><input type="number" id="payoutRateInput" min="10" max="100" step="1" style="width: 60px;"></div><div class="settings-row"><label for="soundToggleCheckbox">B·∫≠t √¢m thanh:</label><input type="checkbox" id="soundToggleCheckbox"></div><hr style="border-color: var(--grid); margin: 20px 0;"><button class="btn-sell" onclick="resetData()">Reset To√†n B·ªô D·ªØ Li·ªáu</button><div class="modal-buttons"><button class="btn-confirm" onclick="applySettings()">L∆∞u & ƒê√≥ng</button></div></div></div>
<audio id="sound-place" src="https://actions.google.com/sounds/v1/ui/camera_shutter.ogg" preload="auto"></audio><audio id="sound-win" src="https://actions.google.com/sounds/v1/impacts/wind_chime_bell_tree.ogg" preload="auto"></audio><audio id="sound-lose" src="https://actions.google.com/sounds/v1/alarms/low_pitch_alarm_clock_ring.ogg" preload="auto"></audio>

<script>
'use strict';
// ===================================================================================
// ===== CONFIG & STATE =====
// ===================================================================================
const coinConfig = {
    'bitcoin': { name: 'BTC', volatilityFactor: 0.0005, initialPrice: 30000 },
    'ethereum': { name: 'ETH', volatilityFactor: 0.0007, initialPrice: 2000 },
    'solana': { name: 'SOL', volatilityFactor: 0.0015, initialPrice: 100 }
};
const config = { initialBalance: 1000, payoutRate: 0.85, candle: { width: 16, bodyRatio: 0.7, colors: { up: '#26a69a', down: '#ef5350', wick: '#aab' } }, ma: { ma5: '#ffa000', ma10: '#2962ff', ma20: '#ff00ff' } };
let balance, currentTrade;
let tradeDuration = 30;
let waitingDuration = 30;
let candles = {}, maxCandles, tempPrice = {};
let currentCoinId = 'bitcoin';
let currentTheme = 'dark';
let isSoundEnabled = true;
let tradeState = 'waiting';
let currentCycleTime = waitingDuration;
let countdownInterval, candleInterval;

const canvas = document.getElementById('chart'); const ctx = canvas.getContext('2d'); const balanceEl = document.getElementById('balance'); const priceEl = document.getElementById('price'); const timerEl = document.getElementById('timer'); const historyListEl = document.getElementById('historyList'); const profitMsgEl = document.getElementById('profitMsg'); const betAmountInput = document.getElementById('betAmountInput');
const themeToggleBtn = document.getElementById('themeToggleBtn');
const panelButtonsEl = document.getElementById('panelButtons');
const rsiCanvas = document.getElementById('rsi-chart'); const rsiCtx = rsiCanvas.getContext('2d');
const plLine = document.getElementById('pl-line'); const plLabel = document.getElementById('pl-label');
const countdownBar = document.getElementById('countdown-bar');
const waitingBar = document.getElementById('waiting-bar');

// ===================================================================================
// ===== INITIALIZATION =====
// ===================================================================================
document.addEventListener('DOMContentLoaded', () => {
    loadState();
    setupCanvas();
    fetchRealPrice();
    setInterval(fetchRealPrice, 7000);
    setInterval(pushCandle, 5000);
    setInterval(miniTick, 200);
    setInterval(updateClock, 1000);
    render(); // Start main render loop
    startTradeCycle(); // Start game loop
    window.addEventListener('resize', setupCanvas);
    betAmountInput.addEventListener('input', updatePotentialPnL);
    themeToggleBtn.addEventListener('click', toggleTheme);
    updatePotentialPnL();
});

// ===================================================================================
// ===== CORE TRADING CYCLE & COUNTDOWN =====
// ===================================================================================
function startTradeCycle() {
    countdownInterval = setInterval(() => {
        currentCycleTime--;

        if (tradeState === 'waiting') {
            updateTimerLabel(currentCycleTime, 'Ch·ªù');
            if (currentCycleTime <= 0) {
                tradeState = 'trading';
                currentCycleTime = tradeDuration;
                if (currentTrade) {
                    balance -= currentTrade.amount;
                    updateBalanceDisplay();
                    currentTrade.openPrice = tempPrice[currentCoinId];
                    plLine.style.display = 'block';
                    plLabel.style.display = 'block';
                    playSound('place');
                }
            }
        } else { // tradeState === 'trading'
            updateTimerLabel(currentCycleTime, 'L·ªánh');
            if (currentCycleTime <= 0) {
                if (currentTrade) {
                    settleTrade(tempPrice[currentTrade.coinId]);
                }
                tradeState = 'waiting';
                currentCycleTime = waitingDuration;
            }
        }
        updateBars();
        updateTradeButtonsUI();
    }, 1000);
}

function updateBars() {
    if (tradeState === 'waiting') {
        waitingBar.style.display = 'block';
        countdownBar.style.display = 'none';
        waitingBar.style.width = `${(currentCycleTime / waitingDuration) * 100}%`;
    } else {
        waitingBar.style.display = 'none';
        countdownBar.style.display = 'block';
        countdownBar.style.width = `${(currentCycleTime / tradeDuration) * 100}%`;
    }
}

// ===================================================================================
// ===== PRICE DATA HANDLING =====
// ===================================================================================
async function fetchRealPrice() {
    const coinIds = Object.keys(coinConfig).join(',');
    try {
        const response = await fetch(`https://api.coingecko.com/api/v3/simple/price?ids=${coinIds}&vs_currencies=usd`);
        if (!response.ok) throw new Error(`Network response was not ok`);
        const data = await response.json();
        
        for (const coinId in data) {
            const newPrice = data[coinId].usd;
            const currentPrice = tempPrice[coinId];

            if (!candles[coinId] || candles[coinId].length === 0) {
                tempPrice[coinId] = newPrice;
                seedFirstCandle(coinId, newPrice);
            } else {
                tempPrice[coinId] = currentPrice ? currentPrice * 0.9 + newPrice * 0.1 : newPrice;
            }
        }
    } catch (error) {
        console.error("Could not fetch price from API:", error);
        priceEl.innerText = "L·ªói API";
    }
}

// ===================================================================================
// ===== CORE TRADING LOGIC =====
// ===================================================================================
function seedFirstCandle(coinId, realPrice) {
    if (!candles[coinId]) candles[coinId] = [];
    candles[coinId].push({ open: realPrice, high: realPrice + 0.5, low: realPrice - 0.5, close: realPrice + (Math.random() - 0.5) * 0.4 });
}
function pushCandle() {
    const price = tempPrice[currentCoinId];
    if (!price) return;
    const currentCandles = candles[currentCoinId];
    const open = currentCandles.length > 0 ? currentCandles[currentCandles.length - 1].close : price;
    const volatility = price * coinConfig[currentCoinId].volatilityFactor;
    const close = open + (Math.random() - 0.5) * volatility;
    const high = Math.max(open, close) + Math.random() * (volatility / 2);
    const low = Math.min(open, close) - Math.random() * (volatility / 2);
    currentCandles.push({ open, high, low, close });
    if (currentCandles.length > maxCandles + 50) { candles[currentCoinId] = currentCandles.slice(- (maxCandles + 50)); }
}
function miniTick() {
    const price = tempPrice[currentCoinId];
    if (!price) return;
    const tickSize = price * 0.00005;
    const delta = (Math.random() - 0.5) * tickSize;
    tempPrice[currentCoinId] += delta;
    const last = candles[currentCoinId] ? candles[currentCoinId][candles[currentCoinId].length - 1] : null;
    if (last) { last.close = tempPrice[currentCoinId]; last.high = Math.max(last.high, tempPrice[currentCoinId]); last.low = Math.min(last.low, tempPrice[currentCoinId]); }
}
function placeTrade(type, amount) {
    if(currentTrade) return alert("Vui l√≤ng ch·ªù l·ªánh hi·ªán t·∫°i k·∫øt th√∫c!");
    if(tradeState !== 'waiting') return alert("Ch·ªâ c√≥ th·ªÉ ƒë·∫∑t l·ªánh trong th·ªùi gian ch·ªù!");
    if(isNaN(amount) || amount <= 0) return alert("S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!");
    if(amount > balance) return alert("Kh√¥ng ƒë·ªß s·ªë d∆∞!");
    
    currentTrade = { type, amount, coinId: currentCoinId }; // openPrice is set when the trade starts
    updateTradeButtonsUI();
}
function cancelTrade() {
    if (currentTrade && tradeState === 'waiting') {
        currentTrade = null;
        updateTradeButtonsUI();
    }
}
function settleTrade(closePrice) {
    if (!currentTrade) return;
    let win = false;
    if (currentTrade.type === 'buy' && closePrice > currentTrade.openPrice) win = true;
    if (currentTrade.type === 'sell' && closePrice < currentTrade.openPrice) win = true;
    
    let amountChange;
    if (win) {
        const winnings = currentTrade.amount * config.payoutRate;
        const totalReturn = currentTrade.amount + winnings;
        balance += totalReturn;
        amountChange = winnings;
        showPL(amountChange, 'win');
    } else {
        amountChange = -currentTrade.amount;
        showPL(amountChange, 'lose');
    }
    addHistory(currentTrade.type, win ? 'win' : 'lose', amountChange, balance, currentTrade.openPrice, closePrice, currentTrade.coinId);
    updateBalanceDisplay(win ? 'win' : 'lose');
    currentTrade = null;
    plLine.style.display = 'none';
    plLabel.style.display = 'none';
    saveState();
}
// ===================================================================================
// ===== UTILITY & STATE MANAGEMENT =====
// ===================================================================================
function switchCoin(coinId) {
    if (currentTrade) {
        alert("Vui l√≤ng ho√†n th√†nh l·ªánh ƒëang giao d·ªãch tr∆∞·ªõc khi chuy·ªÉn c·∫∑p ti·ªÅn!");
        document.getElementById('coinSelector').value = currentCoinId;
        return;
    }
    currentCoinId = coinId;
    const coinName = coinConfig[coinId].name;
    document.getElementById('pairTitle').innerText = `${coinName}/USDT`;
    document.getElementById('priceLabel').innerText = `Gi√° ${coinName} (CoinGecko)`;
    if (!candles[coinId] || candles[coinId].length === 0) fetchRealPrice();
    saveState();
}
function toggleTheme() {
    currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
    document.body.className = currentTheme === 'light' ? 'light-theme' : '';
    themeToggleBtn.innerText = currentTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    saveState();
}
function applySettings() {
    const newPayout = parseInt(document.getElementById('payoutRateInput').value);
    isSoundEnabled = document.getElementById('soundToggleCheckbox').checked;
    
    if (!isNaN(newPayout) && newPayout >= 10 && newPayout <= 100) { 
        config.payoutRate = newPayout / 100; 
        document.getElementById('payoutRateDisplay').innerText = newPayout; 
        updatePotentialPnL(); 
    }
    saveState();
    hideModal('settingsModal');
}
function saveState() { try { const state = { balance, payoutRate: config.payoutRate, history: historyListEl.innerHTML, currentCoinId, currentTheme, isSoundEnabled }; localStorage.setItem('cryptoTradeDemoState', JSON.stringify(state)); } catch (e) { console.error("Failed to save state:", e); } }
function loadState() {
    const savedState = localStorage.getItem('cryptoTradeDemoState');
    if (savedState) {
        const state = JSON.parse(savedState);
        balance = state.balance || config.initialBalance;
        config.payoutRate = state.payoutRate || 0.85;
        historyListEl.innerHTML = state.history || '';
        currentCoinId = state.currentCoinId || 'bitcoin';
        currentTheme = state.currentTheme || 'dark';
        isSoundEnabled = state.isSoundEnabled !== undefined ? state.isSoundEnabled : true;
    } else {
        balance = config.initialBalance;
    }
    updateBalanceDisplay();
    document.getElementById('coinSelector').value = currentCoinId;
    document.getElementById('payoutRateInput').value = Math.round(config.payoutRate * 100);
    document.getElementById('payoutRateDisplay').innerText = Math.round(config.payoutRate * 100);
    document.getElementById('soundToggleCheckbox').checked = isSoundEnabled;
    document.body.className = currentTheme === 'light' ? 'light-theme' : '';
    themeToggleBtn.innerText = currentTheme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
    switchCoin(currentCoinId);
}
function addHistory(type, result, amountChange, newBalance, openPrice, closePrice, coinId) {
    const coinName = coinConfig[coinId].name;
    const li = document.createElement('li');
    const timeStr = new Date().toLocaleTimeString();
    const resultClass = result === 'win' ? 'green' : 'red';
    const amountStr = (amountChange > 0 ? '+' : '') + amountChange.toFixed(2);
    li.innerHTML = `<span class="history-col">[${timeStr}] <b class="${type==='buy'?'green':'red'}">${type.toUpperCase()} ${coinName}</b></span><span class="history-col">${openPrice.toFixed(2)} &#8594; ${closePrice.toFixed(2)}</span><span class="history-col right"><b class="${resultClass}">${amountStr} USDT</b></span><span class="history-col right">S·ªë d∆∞: ${newBalance.toFixed(2)}</span>`;
    historyListEl.prepend(li);
}
// ===================================================================================
// ===== RENDERING & DRAWING =====
// ===================================================================================
function setupCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * dpr;
    canvas.height = 400 * dpr;
    canvas.style.height = '400px';
    ctx.scale(dpr, dpr);
    maxCandles = Math.floor(rect.width / config.candle.width);
    
    rsiCanvas.width = rect.width * dpr;
    rsiCanvas.height = 120 * dpr;
    rsiCanvas.style.height = '120px';
    rsiCtx.scale(dpr, dpr);
}
function getMinMax() { const currentCandles = candles[currentCoinId] || []; const price = tempPrice[currentCoinId]; if (currentCandles.length === 0) return { min: price-1 || 0, max: price+1 || 1 }; const visibleCandles = currentCandles.slice(-maxCandles); const prices = visibleCandles.flatMap(c => [c.high, c.low]); if(price) prices.push(price); let min = Math.min(...prices), max = Math.max(...prices); if(min === max) { min -= 1; max += 1; } const padding = (max - min) * 0.1 || 1; return { min: min - padding, max: max + padding }; }
function yFromPrice(p, min, max) { return 400 - ((p - min) / (max - min)) * 400; }
function drawGrid(min, max) { const w = canvas.clientWidth, h = 400; ctx.strokeStyle = 'var(--grid)'; ctx.lineWidth = 1; ctx.beginPath(); const numLines = 5; for (let i = 0; i <= numLines; i++) { const y = h / numLines * i; ctx.moveTo(0, y); ctx.lineTo(w, y); } ctx.stroke(); }
function drawCandles(min, max) { const bodyW = config.candle.width * config.candle.bodyRatio; const candleData = (candles[currentCoinId] || []).slice(-maxCandles); for(let i=0; i<candleData.length; i++) { const x = i * config.candle.width + config.candle.width / 2; const c = candleData[i]; const yO = yFromPrice(c.open, min, max), yC = yFromPrice(c.close, min, max); const yH = yFromPrice(c.high, min, max), yL = yFromPrice(c.low, min, max); ctx.strokeStyle = config.candle.colors.wick; ctx.lineWidth = 1; ctx.beginPath(); ctx.moveTo(x, yH); ctx.lineTo(x, yL); ctx.stroke(); const isUp = c.close >= c.open; ctx.fillStyle = isUp ? config.candle.colors.up : config.candle.colors.down; ctx.fillRect(x - bodyW / 2, Math.min(yO, yC), bodyW, Math.max(2, Math.abs(yO - yC))); } }
function drawMA(period, color, min, max) { const candleData = (candles[currentCoinId] || []).slice(-maxCandles); if (candleData.length < period) return; const series = []; for(let i=period-1; i<candleData.length; i++) { let sum = 0; for(let j=0; j<period; j++) sum += candleData[i-j].close; series.push({index: i, value: sum/period}); } ctx.strokeStyle = color; ctx.lineWidth = 1.5; ctx.beginPath(); let firstPoint = true; for(const point of series) { const x = point.index * config.candle.width + config.candle.width / 2; const y = yFromPrice(point.value, min, max); if (firstPoint) { ctx.moveTo(x, y); firstPoint = false; } else { ctx.lineTo(x, y); } } ctx.stroke(); }
function drawTradeLine(min, max) { if(!currentTrade || !currentTrade.openPrice) return; const y = yFromPrice(currentTrade.openPrice, min, max); ctx.strokeStyle = currentTrade.type === 'buy' ? 'var(--green)' : 'var(--red)'; ctx.lineWidth = 2; ctx.setLineDash([4, 4]); ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.clientWidth, y); ctx.stroke(); ctx.setLineDash([]); }
function drawLivePrice(min, max) { const price = tempPrice[currentCoinId]; if (!price) return; const y = yFromPrice(price, min, max); document.getElementById('livePriceLine').style.top = `${y}px`; const label = document.getElementById('livePriceLabel'); label.style.top = `${y}px`; label.style.transform = `translateY(-50%)`; label.innerText = price.toFixed(2); if(currentTrade && currentTrade.openPrice) { label.style.background = price > currentTrade.openPrice ? 'var(--green)' : 'var(--red)'; } else { label.style.background = 'var(--yellow)'; } }
function calculateRSI(data, period = 14) { if (data.length <= period) return []; const rsiValues = []; let avgGain = 0, avgLoss = 0; for (let i = 1; i <= period; i++) { const diff = data[i].close - data[i - 1].close; if (diff > 0) avgGain += diff; else avgLoss -= diff;} avgGain /= period; avgLoss /= period; for (let i = period; i < data.length; i++) { const diff = data[i].close - data[i-1].close; let gain = diff > 0 ? diff : 0, loss = diff < 0 ? -diff : 0; avgGain = (avgGain * (period - 1) + gain) / period; avgLoss = (avgLoss * (period - 1) + loss) / period; if (avgLoss === 0) rsiValues.push(100); else { const rs = avgGain / avgLoss; rsiValues.push(100 - (100 / (1 + rs))); } } return rsiValues;}
function drawRSI() {const data = (candles[currentCoinId] || []).slice(-(maxCandles + 15)); const rsiData = calculateRSI(data, 14); const w = rsiCanvas.clientWidth, h = rsiCanvas.clientHeight; rsiCtx.clearRect(0, 0, w, h); const scale = h / 100; rsiCtx.strokeStyle = 'var(--grid)'; rsiCtx.setLineDash([2, 2]); rsiCtx.beginPath(); rsiCtx.moveTo(0, 70 * scale); rsiCtx.lineTo(w, 70 * scale); rsiCtx.moveTo(0, 30 * scale); rsiCtx.lineTo(w, 30 * scale); rsiCtx.stroke(); rsiCtx.setLineDash([]); rsiCtx.strokeStyle = 'var(--yellow)'; rsiCtx.lineWidth = 1.5; rsiCtx.beginPath(); for (let i = 0; i < rsiData.length; i++) { const x = (i + data.length - rsiData.length) * config.candle.width + config.candle.width / 2; const y = h - rsiData[i] * scale; if (i === 0) rsiCtx.moveTo(x, y); else rsiCtx.lineTo(x, y); } rsiCtx.stroke();}
function updatePLGraph() { if (!currentTrade || !currentTrade.openPrice) return; const { min, max } = getMinMax(); const openPriceY = yFromPrice(currentTrade.openPrice, min, max); const currentPriceY = yFromPrice(tempPrice[currentTrade.coinId], min, max); const isWin = (currentTrade.type === 'buy' && tempPrice[currentCoinId] > currentTrade.openPrice) || (currentTrade.type === 'sell' && tempPrice[currentCoinId] < currentTrade.openPrice); const profitLoss = currentTrade.amount * (isWin ? config.payoutRate : -1); plLine.style.top = `${openPriceY}px`; plLine.style.borderColor = isWin ? 'var(--green)' : 'var(--red)'; plLabel.style.top = `${currentPriceY}px`; plLabel.style.left = `50%`; plLabel.style.background = isWin ? 'var(--green)' : 'var(--red)'; plLabel.innerText = `${isWin ? '+' : ''}${profitLoss.toFixed(2)}`; }
function render() {
    priceEl.innerText = tempPrice[currentCoinId] ? tempPrice[currentCoinId].toFixed(2) : 'ƒêang t·∫£i...';
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const { min, max } = getMinMax();
    drawGrid(min, max);
    drawCandles(min, max);
    drawMA(5, config.ma.ma5, min, max);
    drawMA(10, config.ma.ma10, min, max);
    drawMA(20, config.ma.ma20, min, max);
    drawTradeLine(min, max);
    drawLivePrice(min, max);
    updateAxisLabels(min, max);
    updatePLGraph();
    drawRSI();
    requestAnimationFrame(render);
}
// ===================================================================================
// ===== UI & EVENT HANDLERS =====
// ===================================================================================
function updateAxisLabels(min, max) { document.getElementById('axisMax').innerText = max.toFixed(2); document.getElementById('axisMid').innerText = ((min + max) / 2).toFixed(2); document.getElementById('axisMin').innerText = min.toFixed(2); document.getElementById('axisMax').style.top = yFromPrice(max, min, max) + 15 + 'px'; document.getElementById('axisMin').style.top = yFromPrice(min, min, max) - 15 + 'px'; }
function updateBalanceDisplay(result = null) { balanceEl.innerText = balance.toFixed(2); const pill = document.getElementById('balance-pill'); if (result) { const className = result === 'win' ? 'flash-green' : 'flash-red'; pill.classList.add(className); setTimeout(() => pill.classList.remove(className), 500); } }
function updateClock() { const d = new Date(); document.getElementById('date').innerText = d.toLocaleDateString(); document.getElementById('time').innerText = d.toLocaleTimeString(); }
function updateTimerLabel(time, label) { timerEl.innerText = `${label}: 00:${time.toString().padStart(2,'0')}`; }
function updateTradeButtonsUI() {
    if (currentTrade && tradeState === 'waiting') {
        panelButtonsEl.innerHTML = `<button class="btn-cancel-trade" onclick="cancelTrade()">H·ª¶Y L·ªÜNH (${currentTrade.type.toUpperCase()} ${currentTrade.amount.toFixed(2)})</button>`;
    } else {
        panelButtonsEl.innerHTML = `<button class="btn-buy" id="btnBuy" onclick="showModal('betModal', 'buy')">MUA</button><button class="btn-sell" id="btnSell" onclick="showModal('betModal', 'sell')">B√ÅN</button>`;
        const buyBtn = document.getElementById('btnBuy');
        const sellBtn = document.getElementById('btnSell');
        const disabled = tradeState !== 'waiting' || !!currentTrade;
        buyBtn.disabled = disabled;
        sellBtn.disabled = disabled;
        if(disabled){
            buyBtn.title = 'Ch·ªù phi√™n m·ªõi ƒë·ªÉ ƒë·∫∑t l·ªánh';
            sellBtn.title = 'Ch·ªù phi√™n m·ªõi ƒë·ªÉ ƒë·∫∑t l·ªánh';
        }
    }
}
function playSound(type) { if (!isSoundEnabled) return; document.getElementById(`sound-${type}`).play().catch(e => {}); }
function showPL(amount, result) { profitMsgEl.textContent = (amount > 0 ? '+' : '') + amount.toFixed(2) + ' USDT'; profitMsgEl.style.color = amount > 0 ? 'var(--green)' : 'var(--red)'; profitMsgEl.classList.remove('animate'); void profitMsgEl.offsetWidth; profitMsgEl.classList.add('animate'); playSound(result); }
function clearHistory() { if (confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a to√†n b·ªô l·ªãch s·ª≠ giao d·ªãch kh√¥ng?')) { historyListEl.innerHTML = ''; saveState(); } }
let betTypeForModal = '';
function showModal(id, betType) { if (id === 'betModal') { betTypeForModal = betType; const btn = document.getElementById('confirmBetBtn'); const title = document.getElementById('betModalTitle'); const coinName = coinConfig[currentCoinId].name; btn.className = `btn-confirm ${betType === 'buy' ? 'btn-buy' : 'btn-sell'}`; title.textContent = `ƒê·∫∑t L·ªánh ${betType.toUpperCase()} ${coinName}`; title.style.color = betType === 'buy' ? 'var(--green)' : 'var(--red)'; btn.textContent = `X√°c nh·∫≠n`; } document.getElementById(id).classList.add('active'); }
function hideModal(id) { document.getElementById(id).classList.remove('active'); }
document.getElementById('confirmBetBtn').onclick = () => { const amount = parseFloat(betAmountInput.value); hideModal('betModal'); placeTrade(betTypeForModal, amount); };
function updatePotentialPnL() { const amount = parseFloat(betAmountInput.value) || 0; document.getElementById('potentialProfit').textContent = `+${(amount * config.payoutRate).toFixed(2)} USDT`; document.getElementById('potentialLoss').textContent = `-${amount.toFixed(2)} USDT`; }
function deposit() { const v = parseFloat(document.getElementById('depositAmountInput').value); if (!isNaN(v) && v > 0) { balance += v; updateBalanceDisplay('win'); saveState(); hideModal('depositModal'); } else { alert("S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!"); } }
function withdraw() { const v = parseFloat(document.getElementById('withdrawAmountInput').value); if (isNaN(v) || v <= 0) return alert("S·ªë ti·ªÅn kh√¥ng h·ª£p l·ªá!"); if (v > balance) return alert("S·ªë d∆∞ kh√¥ng ƒë·ªß!"); balance -= v; updateBalanceDisplay('lose'); saveState(); hideModal('withdrawModal'); }
function resetData() { if(confirm('B·∫°n c√≥ ch·∫Øc mu·ªën reset to√†n b·ªô d·ªØ li·ªáu (s·ªë d∆∞, l·ªãch s·ª≠, c√†i ƒë·∫∑t) kh√¥ng?')) { localStorage.removeItem('cryptoTradeDemoState'); location.reload(); } }
</script>
</body>
</html>
```
